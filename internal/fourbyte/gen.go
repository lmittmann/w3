//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"slices"
	"strings"
	"sync"
	"text/template"

	"github.com/lmittmann/w3"
)

func main() {
	var (
		errFuncs, errEvents error
		wg                  sync.WaitGroup
	)

	wg.Add(1)
	go func() {
		defer wg.Done()
		errFuncs = genFuncs("funcs.txt", "funcs.go")
	}()
	// go func() {
	// 	defer wg.Done()
	// 	errEvents = genEvents("events.txt", "events.go")
	// }()

	wg.Wait()
	if errFuncs != nil {
		fmt.Printf("error generating functions: %v\n", errFuncs)
	}
	if errEvents != nil {
		fmt.Printf("error generating events: %v\n", errEvents)
	}
	if errFuncs != nil || errEvents != nil {
		os.Exit(1)
	}
}

func genFuncs(fn, goFn string) error {
	// open function definitions
	f, err := os.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()

	// parse function definitions from file
	var functions []function

	scanner := bufio.NewScanner(f)
	for i := 0; scanner.Scan(); i++ {
		tokens := strings.Split(scanner.Text(), "\t")
		if len(tokens) == 1 && strings.HasSuffix(tokens[0], ")") {
			tokens = append(tokens, "") // no returns
		}
		if len(tokens) != 2 {
			return fmt.Errorf("line %d: invalid line %q", i, scanner.Text())
		}

		fn, err := w3.NewFunc(tokens[0], tokens[1])
		if err != nil {
			return fmt.Errorf("line %d: %v", i, err)
		}

		functions = append(functions, function{
			Selector:  fn.Selector,
			Signature: tokens[0],
			Returns:   tokens[1],
		})
	}
	if err := scanner.Err(); err != nil {
		return fmt.Errorf("scan lines: %v", err)
	}

	// make sure function definitions stay in alphabetical order
	slices.SortFunc(functions, func(a, b function) int {
		return strings.Compare(strings.ToLower(a.Signature), strings.ToLower(b.Signature))
	})
	f, err = os.OpenFile(fn, os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	for _, fn := range functions {
		if _, err := f.WriteString(strings.TrimSpace(fn.Signature+"\t"+fn.Returns) + "\n"); err != nil {
			return err
		}
	}

	// generate go file
	goF, err := os.Create(goFn)
	if err != nil {
		return err
	}
	defer goF.Close()

	slices.SortFunc(functions, func(a, b function) int {
		return bytes.Compare(a.Selector[:], b.Selector[:])
	})

	if err := tmplFuncs.Execute(goF, &model{Functions: functions}); err != nil {
		return fmt.Errorf("execute template: %v", err)
	}

	return nil
}

func genEvents(fn, goFn string) error {
	panic("not implemented")
}

type model struct {
	Functions []function
}

type function struct {
	Selector  [4]byte
	Signature string
	Returns   string
}

var (
	tmplFuncs = template.Must(template.New("funcs").Parse(`// Code generated by "go generate"; DO NOT EDIT.
package fourbyte

import "github.com/lmittmann/w3"

var functions = map[[4]byte]*w3.Func{
	{{- range .Functions }}
	{{ printf "{0x%02x, 0x%02x, 0x%02x, 0x%02x}: w3.MustNewFunc(%q, %q)"
		(index .Selector 0)
		(index .Selector 1)
		(index .Selector 2)
		(index .Selector 3)
		.Signature
		.Returns
	}},
	{{- end }}
}
`))

	tmplEvents = template.Must(template.New("events").Parse(`// Code generated by "go generate"; DO NOT EDIT.
package fourbyte

import "github.com/lmittmann/w3"

var events = map[[32]byte]*w3.Event{}
`))
)
