# VM

<DocLink title="w3vm.VM" /> is a super simple to use Ethereum Virtual Machine (EVM), built on to of `go-ethereum/core/vm.EVM`. It supports **tracing**, **state forking** via RPC, and can be used for simulation, debugging EVM execution, or testing Smart Contracts.

* **State forking** via RPC, or custom state fetchers enable transaction simulations or Smart Contract tests on live, or historic chain state.
* **Tracing** of EVM execution is supported via `go-ethereum/core/tracing.Hooks`.


## Get Started

<Steps>

### Create a VM Instance

Create a VM instance, that forks the latest Mainnet state.

```go
client, err := w3.Dial("https://rpc.ankr.com/eth")
if err != nil {
    // ...
}
defer client.Close()

vm, err := w3vm.New(
    w3vm.WithFork(client, nil),
    w3vm.WithNoBaseFee(),
)
if err != nil {
    // ...
}
```

### Simulate a Simple Message

Transfer ETH from the zero address to a random recipient.

```go
recipient := w3vm.RandA()

receipt, err := vm.Apply(&w3types.Message{
    From:  common.Address{},
    To:    &recipient,
    Value: w3.I("1 ether"),
})
if err != nil {
    // ...
}
```

### Verify the Recipient's Balance

Verify the recipient's balance after the applied message.

```go
balance, err := vm.Balance(recipient)
if err != nil {
    // ...
}

fmt.Printf("Balance: %s ETH\n", w3.FromWei(balance, 18))
// Output: Balance: 1 ETH
```

</Steps>


## Setup

A new VM instances is created using the `w3vm.New` function, which accepts various options to customize the VM behavior.

* `WithChainConfig(cfg *params.ChainConfig)`: Sets the chain configuration. If not set, the VM falls back to the Mainnet configuration.
* `WithNoBaseFee()`: Forces the EIP-1559 base fee to 0.
* `WithBlockContext(ctx *vm.BlockContext)`: Sets the block context for the VM.
* `WithHeader(header *types.Header)`: Sets the block context for the VM based on the given header.
* `WithState(state w3types.State)`: Sets the pre state of the VM. If used with `WithFork`, the pre state overrides the forked state.
* `WithStateDB(db *state.StateDB)`: Sets the state database for the VM, that is usually a snapshot obtained from `VM.Snapshot`.
* `WithFork(client *w3.Client, blockNumber *big.Int)`: Forks state from a live Ethereum client at a specific block number.
* `WithFetcher(fetcher Fetcher)`: Sets the fetcher for the VM.
* `WithTB(tb testing.TB)`: Enables persistent state caching when used together with `WithFork`.


## Execution

Messages represent transactions or contract calls that can be executed by the VM.

<Callout type="info">All execution methods support **tracing** via `go-ethereum/core/tracing.Hooks`. [Learn&nbsp;more&nbsp;âž”](/vm-tracing) </Callout>

### `Apply` Method

<DocLink title="Apply" id="w3vm.VM.Apply" /> applies a `w3types.Message` to the VM and returns a `Receipt`. If the execution doesn't revert, the VM's underlying state may change.

#### Example: Apply a Message

```go
msg := &w3types.Message{
    From:  senderAddress,
    To:    &receiverAddress,
    Value: w3.I("1 ether"),
    Gas:   21000,
}

receipt, err := vm.Apply(msg)
if err != nil {
    // ...
}
fmt.Printf("Gas Used: %d\n", receipt.GasUsed)
```

### `ApplyTx` Method

<DocLink title="ApplyTx" id="w3vm.VM.ApplyTx" /> is like `Apply`, but takes a `types.Transaction` instead of a message. The given transaction is converted to a message internally, using a signer, that is derived from the VM's chain configuration and fork block.

### `Call` Method

<DocLink title="Call" id="w3vm.VM.Call" /> is like `Apply`, but any state changes during execution are reverted in the end, so the VM's state is never modified.

#### Example: Call `balanceOf`

```go
funcBalanceOf := w3.MustNewFunc("balanceOf(address)", "uint256")

msg := &w3types.Message{
    To:    &addrToken,
    Func:  funcBalanceOf,
    Args:  []any{ownerAddr},
}

receipt, err := vm.Call(msg)
if err != nil {
    // handle error
}

var balance *big.Int
if err := receipt.DecodeReturns(&balance); err != nil {
    // handle error
}
fmt.Printf("Balance: %s\n", balance)
```

### `CallFunc` Method

<DocLink title="CallFunc" id="w3vm.VM.CallFunc" /> is a helper, that greatly simplifies common usage of `Call`. It is designed analogues to the `eth.CallFunc` RPC client method.

#### Example: Call `balanceOf` with `CallFunc`

This is a simplified version of the [Call `balanceOf`](#example-call-balanceof) example.

```go
funcBalanceOf := w3.MustNewFunc("balanceOf(address)", "uint256")

var balance *big.Int
err := vm.CallFunc(addrToken, funcBalanceOf, ownerAddr).Returns(&balance)
if err != nil {
    // handle error
}
fmt.Printf("Balance: %s\n", balance)
```


## State

The VM provides methods to read, and write account state.

### Reading State

* `vm.Balance(address common.Address) (*big.Int, error)`: Returns the balance of the given address.
* `vm.Nonce(address common.Address) (uint64, error)`: Returns the nonce of the given address.
* `vm.Code(address common.Address) ([]byte, error)`: Returns the code of the given address.
* `vm.StorageAt(address common.Address, slot common.Hash) (common.Hash, error)`: Returns the state of the given address at the give storage slot.

<Callout type="info">
An error only can only occur, if the VM fails to fetch state via a `w3vm.Fetcher`. Thus, it is safe to ignore the error, if no state fetcher is used by the VM.
</Callout>

### Writing State

* `vm.SetBalance(address common.Address, balance *big.Int)`: Sets the balance of the given address.
* `vm.SetNonce(address common.Address, nonce uint64)`: Sets the nonce of the given address.
* `vm.SetCode(address common.Address, code []byte)`: Sets the code of the given address.
* `vm.SetStorageAt(address common.Address, slot common.Hash, value common.Hash)`: Sets the state of the given address at the give storage slot.


**Example:** Simulate an Uniswap v3 swap ([Playground](https://pkg.go.dev/github.com/lmittmann/w3/w3vm#example-VM))

```go
// 1. Create a VM that forks the Mainnet state from the latest block,
// disables the base fee, and has a fake WETH balance and approval for the router
vm, err := w3vm.New(
    w3vm.WithFork(client, nil),
    w3vm.WithNoBaseFee(),
    w3vm.WithState(w3types.State{
        addrWETH: {Storage: w3types.Storage{
            w3vm.WETHBalanceSlot(addrEOA):               common.BigToHash(w3.I("1 ether")),
            w3vm.WETHAllowanceSlot(addrEOA, addrRouter): common.BigToHash(w3.I("1 ether")),
        }},
    }),
)
if err != nil {
    // handle error
}

// 2. Simulate a Uniswap v3 swap
receipt, err := vm.Apply(&w3types.Message{
    From: addrEOA,
    To:   &addrRouter,
    Func: funcExactInput,
    Args: []any{&ExactInputParams{
        Path:             encodePath(addrWETH, 500, addrUNI),
        Recipient:        addrEOA,
        Deadline:         big.NewInt(time.Now().Unix()),
        AmountIn:         w3.I("1 ether"),
        AmountOutMinimum: w3.Big0,
    }},
})
if err != nil {
    // handle error
}

// 3. Decode output amount
var amountOut *big.Int
if err := receipt.DecodeReturns(&amountOut); err != nil {
    // handle error
}
```
